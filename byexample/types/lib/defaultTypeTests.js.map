{"version":3,"sources":["../src/defaultTypeTests.ts"],"names":["defaultTypeTests","extractTypeInfoFunction","extractTypeInfo","boolean","isBoolean","type","name","DefaultTypeName","string","isString","function","isFunction","number","isNumber","values","format","filter","NumberFormat","integer","none","array","isArray","arrayValues","value","allValues","concat","items","object","isObject","objectValues","keyToValuesMap","Map","forEach","objectValue","Object","keys","key","set","get","push","fields","fieldValues","entries"],"mappings":"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","sourcesContent":["import { DefaultTypeName } from './DefaultTypeName';\nimport {\n  isBoolean,\n  isObject,\n  isArray,\n  isString,\n  isFunction,\n  isNumber,\n} from './type-checks';\nimport {\n  DefaultType,\n  BooleanType,\n  StringType,\n  FunctionType,\n  NumberType,\n  NumberFormat,\n  ArrayType,\n  ObjectType,\n} from './type-info-types';\nimport { typeTest, TypeTest } from './TypeTest';\nimport { allAreIntegers } from './util';\nimport { extractTypeInfo } from './extractTypeInfo';\n\nexport function defaultTypeTests(extractTypeInfoFunction = extractTypeInfo) {\n  return {\n    boolean: typeTest(isBoolean, () => {\n      const type: BooleanType = { name: DefaultTypeName.boolean };\n      return type;\n    }),\n    string: typeTest(isString, () => {\n      const type: StringType = { name: DefaultTypeName.string };\n      return type;\n    }),\n    function: typeTest(isFunction, () => {\n      const type: FunctionType = { name: DefaultTypeName.function };\n      return type;\n    }),\n    number: typeTest(isNumber, values => {\n      const type: NumberType = {\n        name: DefaultTypeName.number,\n        format: allAreIntegers(values.filter(isNumber))\n          ? NumberFormat.integer\n          : NumberFormat.none,\n      };\n      return type;\n    }),\n    array: typeTest(isArray, values => {\n      /*\n       * TODO: Currently doesn't necessarily behave as expected.\n       * E.g. Examples = [[1, 1, 1], ['', '', '']] will return a type\n       * that expects an array of both strings and numbers\n       */\n      const arrayValues = values.filter(value => isArray(value));\n      const allValues = [].concat(...arrayValues);\n      const items = extractTypeInfoFunction(allValues);\n      const type: ArrayType = {\n        name: DefaultTypeName.array,\n        items,\n      };\n      return type;\n    }),\n    object: typeTest(isObject, values => {\n      const objectValues = values.filter(value => isObject(value));\n      const keyToValuesMap = new Map<string, { [k: string]: any }>();\n      objectValues.forEach(objectValue => {\n        Object.keys(objectValue).forEach(key => {\n          keyToValuesMap.set(key, []);\n        });\n      });\n      // Gather the values for each key\n      for (const key of keyToValuesMap.keys()) {\n        objectValues.forEach(objectValue => {\n          keyToValuesMap.get(key).push(objectValue[key]);\n        });\n      }\n      // Extract the type info of each field\n      const fields = {};\n      for (const [key, fieldValues] of keyToValuesMap.entries()) {\n        fields[key] = extractTypeInfoFunction(fieldValues);\n      }\n      // Chuck everything into an object type\n      const type: ObjectType = {\n        name: DefaultTypeName.object,\n        fields, // TODO: Should probably lazy load this\n      };\n      return type;\n    }),\n  };\n}\n"],"file":"defaultTypeTests.js"}