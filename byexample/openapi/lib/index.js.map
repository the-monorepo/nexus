{"version":3,"sources":["../src/index.ts"],"names":["addTypeInfoToOpenSchema","openApiType","typeInfo","options","assumeNonNull","nullCount","nullable","mapType","type","byExampleToSwaggerTypeMap","object","objectType","properties","required","assumeRequired","Object","keys","fields","forEach","key","fieldTypeInfo","undefinedCount","push","createSchema","schema","length","string","array","items","number","format","NumberFormat","integer","boolean","mapped","name","optionsWithDefaults","swaggerTypes","types","map","undefined","oneOf","fromTypes"],"mappings":"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","sourcesContent":["import {\n  TypeInfo,\n  ObjectType,\n  StringType,\n  NumberType,\n  ArrayType,\n  BooleanType,\n  Type,\n  NumberFormat,\n} from '@byexample/types';\n\nfunction addTypeInfoToOpenSchema(openApiType, typeInfo, options) {\n  if (options.assumeNonNull) {\n    if (typeInfo.nullCount > 0) {\n      openApiType.nullable = true;\n    }\n  } else {\n    openApiType.nullable = true;\n  }\n}\n\nfunction mapType(type: Type, typeInfo: TypeInfo, options) {\n  const byExampleToSwaggerTypeMap: {\n    [key: string]: (type: Type) => any;\n  } = {\n    object: (objectType: ObjectType) => {\n      const properties = {};\n      const required = [];\n      if (options.assumeRequired) {\n        Object.keys(objectType.fields).forEach(key => {\n          const fieldTypeInfo = objectType.fields[key];\n          if (fieldTypeInfo.undefinedCount <= 0) {\n            required.push(key);\n          }\n        });\n      }\n      Object.keys(objectType.fields).forEach(key => {\n        const fieldTypeInfo = objectType.fields[key];\n        properties[key] = createSchema(fieldTypeInfo, options);\n      });\n      const schema: any = {\n        type: 'object',\n        properties,\n      };\n      if (required.length > 0) {\n        schema.required = required;\n      }\n      return schema;\n    },\n    string: (type: StringType) => {\n      return { type: 'string' };\n    },\n    array: (type: ArrayType) => {\n      return {\n        type: 'array',\n        items: createSchema(type.items, options),\n      };\n    },\n    number: (type: NumberType) => {\n      if (type.format === NumberFormat.integer) {\n        return { type: 'integer' };\n      } else {\n        return { type: 'number' };\n      }\n    },\n    boolean: (type: BooleanType) => {\n      return { type: 'boolean' };\n    },\n  };\n  const mapped = byExampleToSwaggerTypeMap[type.name](type);\n  addTypeInfoToOpenSchema(mapped, typeInfo, options);\n  return mapped;\n}\n\nexport function createSchema(typeInfo: TypeInfo, options = {}) {\n  const optionsWithDefaults = {\n    assumeRequired: true,\n    assumeNonNull: true,\n    ...options,\n  };\n\n  const swaggerTypes = typeInfo.types.map(type =>\n    mapType(type, typeInfo, optionsWithDefaults),\n  );\n  let schema = undefined;\n  if (swaggerTypes.length > 1) {\n    schema = { oneOf: swaggerTypes };\n  } else if (swaggerTypes.length === 1) {\n    schema = swaggerTypes[0];\n  } else {\n    schema = {};\n    addTypeInfoToOpenSchema(schema, typeInfo, options);\n  }\n  return schema;\n}\n\nexport function fromTypes(typeInfo) {\n  return createSchema(typeInfo);\n}\n"],"file":"index.js"}