{"version":3,"sources":["../src/index.ts"],"names":["mbxMemberExpression","field","t","memberExpression","identifier","mbxCallExpression","functionName","args","callExpression","attributeLiteralToHTMLAttributeString","name","literal","type","value","replace","toString","TEXT_TYPE","DYNAMIC_TYPE","ELEMENT_TYPE","SUBCOMPONENT_TYPE","PROPERTY_TYPE","SPREAD_TYPE","EVENT_TYPE","ATTRIBUTE_TYPE","SUBCOMPONENT_PROPERTY_TYPE","domNodeFromJSXText","jsxText","previousIsDynamic","scope","domNodeFromString","isElementTag","tag","toLowerCase","isLiteral","match","isStatic","isArrowFunctionExpression","isFunctionExpression","fieldType","findProgramAndOuterPath","path","parent","parentPath","program","result","isRootJSXNode","isJSXFragment","isJSXElement","isJSXExpressionContainer","cleanFieldName","valueExpressionFromJsxAttributeValue","jsxValue","expression","domNodesFromJSXChildren","jsxChildren","outerPath","children","previousChildIsDynamic","child","node","yieldDomNodeFromNodeSimplified","isDynamicDomlessNode","push","hasDynamicNodes","some","childNode","id","domNodeFromJSXElement","jsxElement","jsxOpeningElement","openingElement","jsxAttributes","attributes","isJSXIdentifier","potentialId","generateUidIdentifier","fields","map","jsxAttribute","key","setterId","setterMap","has","get","elementId","valueId","insertBefore","constDeclaration","arrowFunctionExpression","assignmentExpression","set","childrenAreDynamic","nonStaticAttributeFields","filter","resultNode","length","isJSXSpreadAttribute","argument","nameExpression","childrenTemplateId","aString","html","text","yieldDomNodeFromJSXFragment","jsxFragment","yieldDomNodeFromJSXExpressionContainerNode","isStringLiteral","textNode","isNumericLiteral","isBooleanLiteral","yieldDomNodeFromNodeNonSimplified","isJSXText","Error","domNodeIterator","previous","next","done","current","htmlFromNode","attributeString","join","childrenString","variableDeclaration","variableDeclarator","STATIC_ELEMENT_TEMPLATE_FACTORY_NAME","DYNAMIC_ELEMENT_TEMPLATE_FACTORY_NAME","STATIC_FRAGMENT_TEMPLATE_FACTORY_NAME","DYNAMIC_FRAGMENT_TEMPLATE_FACTORY_NAME","yieldDeclarationStatementsFromRootNodes","nodes","rootId","isRoot","childrenWithDomNodesAssociatedWithThem","firstNode","c","previousNode","numericLiteral","lastNode","dynamicFieldExpression","beforeId","previousConsecutiveDynamicNodeCount","Map","yieldFieldExpressionsFromNodes","dynamicExpression","stringLiteral","yieldFieldValuesFromNode","objectProperties","objectProperty","childArgs","objectExpression","nodeHasDom","yieldTemplateInfoFromRootNodes","templateId","subcomponentNodes","subcomponentNode","yieldTemplateInfoFromSubcomponentNode","nodesWithDom","dynamicElementLength","templateMethod","rootParamId","statements","fieldExpressions","returnStatement","arrayExpression","blockStatement","replacePathWithDomNodeSyntax","templateDeclarations","statement","componentResultArgs","replaceWith","expressionStatement","api","options","assertVersion","THROW_IF_NAMESPACE","throwIfNamespace","undefined","PRAGMA_DEFAULT","pragma","PRAGMA_FRAG_DEFAULT","pragmaFrag","JSX_ANNOTATION_REGEX","JSX_FRAG_ANNOTATION_REGEX","createIdentifierParser","split","reduce","object","property","visitor","pre","state","tagName","react","isCompatTag","tagExpr","post","pass","callee","Program","enter","file","pragmaSet","pragmaFragSet","ast","comments","comment","jsxMatches","exec","jsxFragMatches","exit","JSXFragment","domNodes","JSXElement","domNode","inherits","jsx"],"mappings":"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","sourcesContent":["import { declare } from '@babel/helper-plugin-utils';\r\nimport jsx from '@babel/plugin-syntax-jsx';\r\nimport helper from '@babel/helper-builder-react-jsx';\r\nimport { types as t } from '@babel/core';\r\n\r\nconst mbxMemberExpression = (field: string) => {\r\n  return t.memberExpression(t.identifier('mbx'), t.identifier(field));\r\n};\r\n\r\nconst mbxCallExpression = (functionName, args) => {\r\n  return t.callExpression(mbxMemberExpression(functionName), args);\r\n};\r\n\r\nconst attributeLiteralToHTMLAttributeString = (name: string, literal) => {\r\n  if (literal === false) {\r\n    /*\r\n      To represent a false value, the attribute has to be omitted altogether.\r\n      @see https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#boolean-attributes\r\n    */\r\n    return '';\r\n  }\r\n  if (literal === null) {\r\n    // This is like <element attrName/>\r\n    return `${name}`;\r\n  }\r\n  switch (literal.type) {\r\n    case 'StringLiteral':\r\n      return `${name}=\"${literal.value.replace(/\"/g, '\\\\\"')}\"`;\r\n    case 'BooleanLiteral':\r\n      return literal.value ? name : '';\r\n    case 'NumericLiteral':\r\n      return `${name}=\"${literal.value}\"`;\r\n    default:\r\n      return `${name}=\"${literal.value.toString()}\"`;\r\n  }\r\n};\r\n\r\nconst TEXT_TYPE = 'text';\r\nconst DYNAMIC_TYPE = 'dynamic';\r\nconst ELEMENT_TYPE = 'element';\r\nconst SUBCOMPONENT_TYPE = 'subcomponent';\r\n\r\nconst PROPERTY_TYPE = 'property';\r\nconst SPREAD_TYPE = 'spread';\r\nconst EVENT_TYPE = 'event';\r\nconst ATTRIBUTE_TYPE = 'attribute';\r\n\r\ninterface PropertyField {\r\n  type: typeof PROPERTY_TYPE;\r\n  key: string;\r\n  expression: any;\r\n  setterId: any;\r\n}\r\ninterface SpreadField {\r\n  type: typeof SPREAD_TYPE;\r\n  expression: any;\r\n}\r\ninterface EventField {\r\n  type: typeof EVENT_TYPE;\r\n  key: string;\r\n  expression: any;\r\n}\r\ninterface AttributeField {\r\n  type: typeof ATTRIBUTE_TYPE;\r\n  key: string;\r\n  expression: any;\r\n}\r\ntype ElementField = AttributeField | PropertyField | EventField; // TODO: SpreadType\r\n\r\n/**\r\n * We have no idea how many node will be in this section.\r\n * Could be 0, could be 100\r\n */\r\ninterface DynamicSection {\r\n  type: typeof DYNAMIC_TYPE;\r\n  expression: any;\r\n}\r\n/**\r\n * Just a typical HTML/XML element\r\n */\r\ninterface ElementNode {\r\n  type: typeof ELEMENT_TYPE;\r\n  tag: string;\r\n  children: Node[];\r\n  fields: ElementField[];\r\n  id: any;\r\n}\r\n\r\nconst SUBCOMPONENT_PROPERTY_TYPE = 'subcomponent_property';\r\ninterface SubcomponentPropertyField {\r\n  type: typeof SUBCOMPONENT_PROPERTY_TYPE;\r\n  key: string;\r\n  expression: any;\r\n}\r\n\r\ntype SubcomponentField = SubcomponentPropertyField | SpreadField;\r\n\r\n/**\r\n * Represents things like:\r\n * <Subcomponent><child>...</child>...</SubComponent>\r\n * Note that this is similar to a DynamicSection in that we have\r\n * no idea how many root nodes the subcomponent represents:\r\n * Could be 0, could 100\r\n */\r\ninterface SubcomponentNode {\r\n  type: typeof SUBCOMPONENT_TYPE;\r\n  nameExpression: any;\r\n  children: Node[];\r\n  childrenTemplateId: any;\r\n  fields: SubcomponentField[];\r\n}\r\n/**\r\n * Just a text node\r\n */\r\ninterface TextNode {\r\n  type: typeof TEXT_TYPE;\r\n  text: string;\r\n  id?: any;\r\n}\r\ntype Node = DynamicSection | ElementNode | TextNode | SubcomponentNode;\r\nfunction domNodeFromJSXText(jsxText, previousIsDynamic: boolean, scope) {\r\n  return domNodeFromString(jsxText.value, previousIsDynamic, scope);\r\n}\r\n\r\nconst isElementTag = (tag: string) => {\r\n  return tag[0].toLowerCase() === tag[0];\r\n};\r\n\r\nconst isLiteral = (value): boolean => value && value.type.match(/Literal$/);\r\n\r\nconst isStatic = value => {\r\n  return (\r\n    value &&\r\n    (isLiteral(value) ||\r\n      t.isArrowFunctionExpression(value) ||\r\n      t.isFunctionExpression(value))\r\n  );\r\n};\r\n\r\nconst fieldType = (name: string) => {\r\n  return name.match(/^\\$\\$/)\r\n    ? EVENT_TYPE\r\n    : name.match(/^\\$/)\r\n    ? PROPERTY_TYPE\r\n    : ATTRIBUTE_TYPE;\r\n};\r\n\r\nconst findProgramAndOuterPath = path => {\r\n  const parent = path.parentPath;\r\n  if (!parent) {\r\n    return { program: path };\r\n  } else {\r\n    const result = findProgramAndOuterPath(parent);\r\n    if (result.path) {\r\n      return result;\r\n    } else {\r\n      return { program: result.program, path: path };\r\n    }\r\n  }\r\n};\r\n\r\nconst isRootJSXNode = path => {\r\n  const parent = path.parent;\r\n  if (t.isJSXFragment(parent) || t.isJSXElement(parent)) {\r\n    return false;\r\n  } else if (t.isJSXExpressionContainer(parent)) {\r\n    // TODO: Very confusing condition\r\n    return isRootJSXNode(path.parentPath);\r\n  } else {\r\n    return true;\r\n  }\r\n};\r\n\r\nconst cleanFieldName = (name: string) => name.replace(/^\\$?\\$?/, '');\r\n\r\nconst valueExpressionFromJsxAttributeValue = jsxValue =>\r\n  t.isJSXExpressionContainer(jsxValue) ? jsxValue.expression : jsxValue;\r\n\r\nconst domNodesFromJSXChildren = (jsxChildren, scope, outerPath): any[] => {\r\n  const children: Node[] = [];\r\n  let previousChildIsDynamic = false;\r\n  for (const child of jsxChildren) {\r\n    for (const node of yieldDomNodeFromNodeSimplified(\r\n      child,\r\n      previousChildIsDynamic,\r\n      scope,\r\n      outerPath,\r\n    )) {\r\n      previousChildIsDynamic = isDynamicDomlessNode(node);\r\n      children.push(node);\r\n    }\r\n  }\r\n  return children;\r\n};\r\n\r\nconst hasDynamicNodes = (children: Node[]) => {\r\n  return children.some(\r\n    childNode =>\r\n      childNode.type === DYNAMIC_TYPE ||\r\n      (childNode.type === ELEMENT_TYPE && childNode.id),\r\n  );\r\n};\r\n\r\nconst domNodeFromJSXElement = (\r\n  jsxElement,\r\n  previousIsDynamic,\r\n  scope,\r\n  outerPath,\r\n): SubcomponentNode | ElementNode => {\r\n  const jsxOpeningElement = jsxElement.openingElement;\r\n\r\n  const jsxAttributes = jsxElement.openingElement.attributes;\r\n  if (\r\n    t.isJSXIdentifier(jsxOpeningElement.name) &&\r\n    isElementTag(jsxOpeningElement.name.name)\r\n  ) {\r\n    const tag = jsxOpeningElement.name.name;\r\n    const potentialId = scope.generateUidIdentifier(`${tag}$`);\r\n    const fields: ElementField[] = jsxAttributes.map(\r\n      (jsxAttribute): ElementField => {\r\n        const type = fieldType(jsxAttribute.name.name);\r\n        switch (type) {\r\n          case PROPERTY_TYPE:\r\n            const key = cleanFieldName(jsxAttribute.name.name);\r\n            const setterId = (() => {\r\n              if (setterMap.has(key)) {\r\n                return setterMap.get(key);\r\n              } else {\r\n                const id = outerPath.scope.generateUidIdentifier(`${key}$setter`);\r\n                const elementId = outerPath.scope.generateUidIdentifier('element');\r\n                const valueId = outerPath.scope.generateUidIdentifier('value');\r\n                outerPath.insertBefore(\r\n                  constDeclaration(\r\n                    id,\r\n                    t.arrowFunctionExpression(\r\n                      [elementId, valueId],\r\n                      t.assignmentExpression(\r\n                        '=',\r\n                        t.memberExpression(elementId, t.identifier(key)),\r\n                        valueId,\r\n                      ),\r\n                    ),\r\n                  ),\r\n                );\r\n                setterMap.set(key, id);\r\n                return id;\r\n              }\r\n            })();\r\n            return {\r\n              type,\r\n              setterId,\r\n              expression: valueExpressionFromJsxAttributeValue(jsxAttribute.value),\r\n              key,\r\n            };\r\n          default:\r\n            return {\r\n              type,\r\n              key: cleanFieldName(jsxAttribute.name.name),\r\n              expression: valueExpressionFromJsxAttributeValue(jsxAttribute.value),\r\n            } as ElementField;\r\n        }\r\n      },\r\n    );\r\n    const children = domNodesFromJSXChildren(jsxElement.children, scope, outerPath);\r\n    const childrenAreDynamic = hasDynamicNodes(children);\r\n    const nonStaticAttributeFields = fields.filter(\r\n      field => !(field.type === ATTRIBUTE_TYPE && isLiteral(field.expression)),\r\n    );\r\n    const resultNode: ElementNode = {\r\n      type: ELEMENT_TYPE,\r\n      tag,\r\n      children,\r\n      fields,\r\n      id:\r\n        previousIsDynamic || childrenAreDynamic || nonStaticAttributeFields.length > 0\r\n          ? potentialId\r\n          : null,\r\n    };\r\n    return resultNode;\r\n  } else {\r\n    const fields: SubcomponentField[] = jsxAttributes.map(\r\n      (jsxAttribute): SubcomponentField => {\r\n        if (t.isJSXSpreadAttribute(jsxAttribute)) {\r\n          const result: SpreadField = {\r\n            type: SPREAD_TYPE,\r\n            expression: jsxAttribute.argument, // TODO: Check this is right\r\n          };\r\n          return result;\r\n        } else {\r\n          const result: SubcomponentPropertyField = {\r\n            type: SUBCOMPONENT_PROPERTY_TYPE,\r\n            key: jsxAttribute.name.name,\r\n            expression: valueExpressionFromJsxAttributeValue(jsxAttribute.value),\r\n          };\r\n          return result;\r\n        }\r\n      },\r\n    );\r\n    const children = domNodesFromJSXChildren(jsxElement.children, scope, outerPath);\r\n    const resultNode: SubcomponentNode = {\r\n      type: SUBCOMPONENT_TYPE,\r\n      nameExpression: jsxOpeningElement.name,\r\n      children,\r\n      childrenTemplateId:\r\n        children.length > 0 ? scope.generateUidIdentifier('subTemplate') : null,\r\n      fields,\r\n    };\r\n    return resultNode;\r\n  }\r\n};\r\n\r\nconst domNodeFromString = (\r\n  aString: string,\r\n  previousIsDynamic: boolean,\r\n  scope,\r\n): TextNode | null => {\r\n  const html = aString.replace(/^\\s*\\n\\s*|\\s*\\n\\s*$/g, '');\r\n  if (html === '') {\r\n    return null;\r\n  }\r\n  return {\r\n    type: TEXT_TYPE,\r\n    text: html,\r\n    id: previousIsDynamic ? scope.generateUidIdentifier('text') : null,\r\n  };\r\n};\r\n\r\nconst isDynamicDomlessNode = (node: Node) => {\r\n  return node.type === DYNAMIC_TYPE || node.type === SUBCOMPONENT_TYPE;\r\n};\r\n\r\nfunction* yieldDomNodeFromJSXFragment(\r\n  jsxFragment,\r\n  previousIsDynamic: boolean,\r\n  scope,\r\n  outerPath,\r\n) {\r\n  for (const child of jsxFragment.children) {\r\n    for (const node of yieldDomNodeFromNodeSimplified(\r\n      child,\r\n      previousIsDynamic,\r\n      scope,\r\n      outerPath,\r\n    )) {\r\n      previousIsDynamic = isDynamicDomlessNode(node);\r\n      yield node;\r\n    }\r\n  }\r\n}\r\n\r\nfunction* yieldDomNodeFromJSXExpressionContainerNode(\r\n  node,\r\n  previousIsDynamic: boolean,\r\n  scope,\r\n  outerPath,\r\n): IterableIterator<Node> {\r\n  const expression = node.expression;\r\n  // TODO: Function and array literals\r\n  if (t.isJSXElement(expression) || t.isJSXFragment(expression)) {\r\n    yield* yieldDomNodeFromNodeSimplified(\r\n      expression,\r\n      previousIsDynamic,\r\n      scope,\r\n      outerPath,\r\n    );\r\n  } else if (t.isStringLiteral(expression)) {\r\n    // TODO: Two contained literals next to each other would lead to incorrect state length\r\n    const textNode = domNodeFromString(expression.value, previousIsDynamic, scope);\r\n    if (textNode) {\r\n      yield textNode;\r\n    }\r\n  } else if (t.isNumericLiteral(expression) || t.isBooleanLiteral(expression)) {\r\n    const textNode = domNodeFromString(\r\n      expression.value.toString(),\r\n      previousIsDynamic,\r\n      scope,\r\n    );\r\n    if (textNode) {\r\n      yield textNode;\r\n    }\r\n  } else {\r\n    yield {\r\n      type: DYNAMIC_TYPE,\r\n      expression,\r\n    };\r\n  }\r\n}\r\n\r\nfunction* yieldDomNodeFromNodeNonSimplified(\r\n  node,\r\n  previousIsDynamic,\r\n  scope,\r\n  outerPath,\r\n): IterableIterator<Node> {\r\n  if (t.isJSXElement(node)) {\r\n    yield domNodeFromJSXElement(node, previousIsDynamic, scope, outerPath);\r\n  } else if (t.isJSXExpressionContainer(node)) {\r\n    yield* yieldDomNodeFromJSXExpressionContainerNode(\r\n      node,\r\n      previousIsDynamic,\r\n      scope,\r\n      outerPath,\r\n    );\r\n  } else if (t.isJSXFragment(node)) {\r\n    yield* yieldDomNodeFromJSXFragment(node, previousIsDynamic, scope, outerPath);\r\n  } else if (t.isJSXText(node)) {\r\n    const textNode = domNodeFromJSXText(node, previousIsDynamic, scope);\r\n    if (textNode) {\r\n      yield textNode;\r\n    }\r\n  } else {\r\n    throw new Error(`Invalid node type ${node.type}`);\r\n  }\r\n}\r\n\r\nfunction* yieldDomNodeFromNodeSimplified(\r\n  node,\r\n  previousIsDynamic: boolean,\r\n  scope,\r\n  outerPath,\r\n): IterableIterator<Node> {\r\n  const domNodeIterator = yieldDomNodeFromNodeNonSimplified(\r\n    node,\r\n    previousIsDynamic,\r\n    scope,\r\n    outerPath,\r\n  );\r\n  let previous = domNodeIterator.next();\r\n  if (!previous.done) {\r\n    if (previous.value.type !== TEXT_TYPE) {\r\n      yield previous.value;\r\n    }\r\n    let current = domNodeIterator.next();\r\n    while (!current.done) {\r\n      if (previous.value.type === TEXT_TYPE && current.value.type === TEXT_TYPE) {\r\n        // If there's two text nodes you can just concacatinate them\r\n        previous.value.text += current.value.text;\r\n        current = domNodeIterator.next();\r\n      } else if (previous.value.type === TEXT_TYPE) {\r\n        yield previous.value;\r\n      } else {\r\n        yield current.value;\r\n        previous = current;\r\n        current = domNodeIterator.next();\r\n      }\r\n    }\r\n    if (previous.value.type === TEXT_TYPE) {\r\n      yield previous.value;\r\n    }\r\n  }\r\n}\r\n\r\nconst htmlFromNode = (node: Node): string => {\r\n  switch (node.type) {\r\n    case ELEMENT_TYPE:\r\n      const tag: string = node.tag;\r\n      const attributeString: string = (node.fields.filter(\r\n        field => field.type === ATTRIBUTE_TYPE && isLiteral(field.expression),\r\n      ) as AttributeField[])\r\n        .map(field => attributeLiteralToHTMLAttributeString(field.key, field.expression))\r\n        .join(' ');\r\n      const childrenString: string = node.children\r\n        .map(field => {\r\n          return htmlFromNode(field);\r\n        })\r\n        .join('');\r\n      return `<${tag}${\r\n        attributeString !== '' ? ` ${attributeString}` : ''\r\n      }>${childrenString}</${tag}>`;\r\n    case TEXT_TYPE:\r\n      return node.text;\r\n    default:\r\n      return '';\r\n  }\r\n};\r\n\r\nconst constDeclaration = (id, expression) => {\r\n  return t.variableDeclaration('const', [t.variableDeclarator(id, expression)]);\r\n};\r\n\r\nconst STATIC_ELEMENT_TEMPLATE_FACTORY_NAME = 'staticElementBlueprint';\r\nconst DYNAMIC_ELEMENT_TEMPLATE_FACTORY_NAME = 'elementBlueprint';\r\nconst STATIC_FRAGMENT_TEMPLATE_FACTORY_NAME = 'staticFragmentBlueprint';\r\nconst DYNAMIC_FRAGMENT_TEMPLATE_FACTORY_NAME = 'fragmentBlueprint';\r\n\r\nfunction* yieldDeclarationStatementsFromRootNodes(\r\n  nodes: Node[],\r\n  rootId: any,\r\n  isRoot: boolean,\r\n) {\r\n  const childrenWithDomNodesAssociatedWithThem: ElementNode[] = nodes.filter(\r\n    child => child.type === ELEMENT_TYPE,\r\n  ) as ElementNode[];\r\n\r\n  if (childrenWithDomNodesAssociatedWithThem.length > 0) {\r\n    const firstNode = childrenWithDomNodesAssociatedWithThem[0];\r\n    if (firstNode.id) {\r\n      if (isRoot && childrenWithDomNodesAssociatedWithThem.length === 1) {\r\n        yield constDeclaration(firstNode.id, rootId);\r\n      } else {\r\n        yield constDeclaration(\r\n          firstNode.id,\r\n          t.memberExpression(rootId, t.identifier('firstChild')),\r\n        );\r\n      }\r\n      yield* yieldDeclarationStatementsFromRootNodes(\r\n        firstNode.children,\r\n        firstNode.id,\r\n        false,\r\n      );\r\n    }\r\n    for (let c = 1; c < childrenWithDomNodesAssociatedWithThem.length - 1; c++) {\r\n      const childNode = childrenWithDomNodesAssociatedWithThem[c];\r\n      if (childNode.id) {\r\n        const previousNode = childrenWithDomNodesAssociatedWithThem[c - 1];\r\n        if (previousNode.id) {\r\n          yield constDeclaration(\r\n            childNode.id,\r\n            t.memberExpression(previousNode.id, t.identifier('nextSibling')),\r\n          );\r\n        } else {\r\n          yield constDeclaration(\r\n            childNode.id,\r\n            t.memberExpression(\r\n              t.memberExpression(rootId, t.identifier('childNodes')),\r\n              t.numericLiteral(c),\r\n              true,\r\n            ),\r\n          );\r\n        }\r\n        yield* yieldDeclarationStatementsFromRootNodes(\r\n          childNode.children,\r\n          childNode.id,\r\n          false,\r\n        );\r\n      }\r\n    }\r\n    // TODO: Could do previousSibling if the last node uses lastChild\r\n    if (childrenWithDomNodesAssociatedWithThem.length >= 2) {\r\n      const lastNode =\r\n        childrenWithDomNodesAssociatedWithThem[\r\n          childrenWithDomNodesAssociatedWithThem.length - 1\r\n        ];\r\n      if (lastNode.id) {\r\n        yield constDeclaration(\r\n          lastNode.id,\r\n          t.memberExpression(rootId, t.identifier('lastChild')),\r\n        );\r\n        yield* yieldDeclarationStatementsFromRootNodes(\r\n          lastNode.children,\r\n          lastNode.id,\r\n          false,\r\n        );\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nconst dynamicFieldExpression = (\r\n  rootId,\r\n  beforeId,\r\n  previousConsecutiveDynamicNodeCount: number,\r\n) => {\r\n  if (previousConsecutiveDynamicNodeCount === 1) {\r\n    return mbxCallExpression('children', [rootId, beforeId]);\r\n  } else if (previousConsecutiveDynamicNodeCount >= 2) {\r\n    return mbxCallExpression('dynamicSection', [\r\n      rootId,\r\n      beforeId,\r\n      t.numericLiteral(previousConsecutiveDynamicNodeCount),\r\n    ]);\r\n  }\r\n  return null;\r\n};\r\n\r\nconst setterMap = new Map();\r\nfunction* yieldFieldExpressionsFromNodes(nodes: Node[], rootId) {\r\n  let previousConsecutiveDynamicNodeCount = 0;\r\n  for (const node of nodes) {\r\n    switch (node.type) {\r\n      case TEXT_TYPE:\r\n      case ELEMENT_TYPE:\r\n        const dynamicExpression = dynamicFieldExpression(\r\n          rootId,\r\n          node.id,\r\n          previousConsecutiveDynamicNodeCount,\r\n        );\r\n        if (dynamicExpression !== null) {\r\n          yield dynamicExpression;\r\n        }\r\n        previousConsecutiveDynamicNodeCount = 0;\r\n        if (node.type === ELEMENT_TYPE) {\r\n          for (const field of node.fields) {\r\n            switch (field.type) {\r\n              case EVENT_TYPE:\r\n              case ATTRIBUTE_TYPE:\r\n                if (!isLiteral(field.expression)) {\r\n                  yield mbxCallExpression(field.type, [\r\n                    node.id,\r\n                    t.stringLiteral(field.key),\r\n                  ]);\r\n                }\r\n                break;\r\n              case PROPERTY_TYPE:\r\n                yield mbxCallExpression(field.type, [node.id, field.setterId]);\r\n                break;\r\n            }\r\n          }\r\n          yield* yieldFieldExpressionsFromNodes(node.children, node.id);\r\n        }\r\n        break;\r\n      case SUBCOMPONENT_TYPE:\r\n      case DYNAMIC_TYPE:\r\n        previousConsecutiveDynamicNodeCount++;\r\n        break;\r\n    }\r\n  }\r\n  const dynamicExpression = dynamicFieldExpression(\r\n    rootId,\r\n    t.identifier('null'),\r\n    previousConsecutiveDynamicNodeCount,\r\n  );\r\n  if (dynamicExpression !== null) {\r\n    yield dynamicExpression;\r\n  }\r\n}\r\n\r\nfunction* yieldFieldValuesFromNode(node: Node) {\r\n  switch (node.type) {\r\n    case ELEMENT_TYPE:\r\n      for (const field of node.fields) {\r\n        switch (field.type) {\r\n          case ATTRIBUTE_TYPE:\r\n            if (!isLiteral(field.expression)) {\r\n              yield field.expression;\r\n            }\r\n            break;\r\n          default:\r\n            yield field.expression;\r\n        }\r\n      }\r\n      for (const childNode of node.children) {\r\n        yield* yieldFieldValuesFromNode(childNode);\r\n      }\r\n      break;\r\n    case DYNAMIC_TYPE:\r\n      yield node.expression;\r\n      break;\r\n    case SUBCOMPONENT_TYPE:\r\n      const objectProperties: any[] = [];\r\n      for (const field of node.fields) {\r\n        switch (field.type) {\r\n          case SPREAD_TYPE:\r\n            objectProperties.push(field.expression);\r\n            break;\r\n          case SUBCOMPONENT_PROPERTY_TYPE:\r\n            objectProperties.push(\r\n              t.objectProperty(t.identifier(field.key), field.expression),\r\n            );\r\n            break;\r\n        }\r\n      }\r\n      if (node.childrenTemplateId) {\r\n        const childArgs: any[] = [node.childrenTemplateId];\r\n        for (const childNode of node.children) {\r\n          childArgs.push(...yieldFieldValuesFromNode(childNode));\r\n        }\r\n        objectProperties.push(\r\n          t.objectProperty(\r\n            t.identifier('children'),\r\n            mbxCallExpression('componentResult', childArgs),\r\n          ),\r\n        );\r\n      }\r\n      // TODO: This whole block of code assumes that it's a SFC and not a string (representing an HTML element)\r\n      yield t.callExpression(t.identifier(node.nameExpression.name), [\r\n        t.objectExpression(objectProperties),\r\n      ]);\r\n  }\r\n}\r\n\r\nconst nodeHasDom = (node: Node) => node.type === ELEMENT_TYPE || node.type === TEXT_TYPE;\r\n\r\nfunction* yieldTemplateInfoFromRootNodes(nodes: Node[], templateId, scope) {\r\n  const subcomponentNodes: SubcomponentNode[] = nodes.filter(\r\n    node => node.type === SUBCOMPONENT_TYPE,\r\n  ) as SubcomponentNode[];\r\n  for (const subcomponentNode of subcomponentNodes) {\r\n    yield* yieldTemplateInfoFromSubcomponentNode(subcomponentNode, scope);\r\n  }\r\n\r\n  const nodesWithDom: (ElementNode | TextNode)[] = nodes.filter(nodeHasDom) as (\r\n    | ElementNode\r\n    | TextNode)[];\r\n  const dynamicElementLength = nodes.filter(\r\n    node =>\r\n      node.type === DYNAMIC_TYPE ||\r\n      node.type === SUBCOMPONENT_TYPE ||\r\n      (node.type === ELEMENT_TYPE && node.id),\r\n  ).length;\r\n  const args = [t.stringLiteral(nodes.map(node => htmlFromNode(node)).join(''))];\r\n  let templateMethod: string;\r\n  if (nodesWithDom.length <= 0) {\r\n    return;\r\n  } else if (nodesWithDom.length === 1) {\r\n    if (dynamicElementLength > 0) {\r\n      templateMethod = DYNAMIC_ELEMENT_TEMPLATE_FACTORY_NAME;\r\n    } else {\r\n      templateMethod = STATIC_ELEMENT_TEMPLATE_FACTORY_NAME;\r\n    }\r\n  } else {\r\n    if (dynamicElementLength > 0) {\r\n      templateMethod = DYNAMIC_FRAGMENT_TEMPLATE_FACTORY_NAME;\r\n    } else {\r\n      templateMethod = STATIC_FRAGMENT_TEMPLATE_FACTORY_NAME;\r\n    }\r\n  }\r\n  if (dynamicElementLength > 0) {\r\n    const rootParamId = scope.generateUidIdentifier('rootNode');\r\n    const statements = [\r\n      ...yieldDeclarationStatementsFromRootNodes(nodes, rootParamId, true),\r\n    ];\r\n    const fieldExpressions = [...yieldFieldExpressionsFromNodes(nodes, rootParamId)];\r\n    statements.push(t.returnStatement(t.arrayExpression(fieldExpressions)));\r\n    args.push(t.arrowFunctionExpression([rootParamId], t.blockStatement(statements)));\r\n  }\r\n  yield constDeclaration(templateId, mbxCallExpression(templateMethod, args));\r\n}\r\n\r\nfunction* yieldTemplateInfoFromSubcomponentNode(node: SubcomponentNode, scope) {\r\n  if (node.childrenTemplateId) {\r\n    yield* yieldTemplateInfoFromRootNodes(node.children, node.childrenTemplateId, scope);\r\n  }\r\n}\r\n\r\nconst replacePathWithDomNodeSyntax = (nodes: Node[], path, outerPath) => {\r\n  const templateId = path.scope.generateUidIdentifier('template');\r\n  const templateDeclarations = yieldTemplateInfoFromRootNodes(\r\n    nodes,\r\n    templateId,\r\n    path.scope,\r\n  );\r\n  for (const statement of templateDeclarations) {\r\n    outerPath.insertBefore(statement);\r\n  }\r\n  const nodesWithDom = nodes.filter(nodeHasDom);\r\n  if (nodesWithDom.length <= 0) {\r\n    const componentResultArgs: any[] = [];\r\n    for (const node of nodes) {\r\n      componentResultArgs.push(...yieldFieldValuesFromNode(node));\r\n    }\r\n    if (componentResultArgs.length === 1) {\r\n      path.replaceWith(t.expressionStatement(componentResultArgs[0]));\r\n    } else {\r\n      path.replaceWith(t.expressionStatement(t.arrayExpression(componentResultArgs)));\r\n    }\r\n  } else {\r\n    const componentResultArgs = [templateId];\r\n    for (const node of nodes) {\r\n      componentResultArgs.push(t.arrayExpression([...yieldFieldValuesFromNode(node)]));\r\n    }\r\n    path.replaceWith(\r\n      t.expressionStatement(mbxCallExpression('componentResult', componentResultArgs)),\r\n    );\r\n  }\r\n};\r\n\r\nexport default declare((api, options) => {\r\n  api.assertVersion(7);\r\n\r\n  const THROW_IF_NAMESPACE =\r\n    options.throwIfNamespace === undefined ? true : !!options.throwIfNamespace;\r\n\r\n  const PRAGMA_DEFAULT = options.pragma || 'mbx.createElement';\r\n  const PRAGMA_FRAG_DEFAULT = options.pragmaFrag || 'mbx.Fragment';\r\n\r\n  const JSX_ANNOTATION_REGEX = /\\*?\\s*@jsx\\s+([^\\s]+)/;\r\n  const JSX_FRAG_ANNOTATION_REGEX = /\\*?\\s*@jsxFrag\\s+([^\\s]+)/;\r\n\r\n  // returns a closure that returns an identifier or memberExpression node\r\n  // based on the given id\r\n  const createIdentifierParser = (id: string) => () => {\r\n    return id\r\n      .split('.')\r\n      .map(name => t.identifier(name))\r\n      .reduce((object, property) => t.memberExpression(object, property));\r\n  };\r\n\r\n  const visitor = helper({\r\n    pre(state) {\r\n      const tagName = state.tagName;\r\n      const args = state.args;\r\n      if (t.react.isCompatTag(tagName)) {\r\n        args.push(t.stringLiteral(tagName));\r\n      } else {\r\n        args.push(state.tagExpr);\r\n      }\r\n    },\r\n\r\n    post(state, pass) {\r\n      state.callee = pass.get('jsxIdentifier')();\r\n    },\r\n\r\n    throwIfNamespace: THROW_IF_NAMESPACE,\r\n  });\r\n\r\n  visitor.Program = {\r\n    enter(path, state) {\r\n      const { file } = state;\r\n      //path.unshift(t.memberExpression(t.identifier('swek'), t.identifier(1)));\r\n      let pragma = PRAGMA_DEFAULT;\r\n      let pragmaFrag = PRAGMA_FRAG_DEFAULT;\r\n      let pragmaSet = !!options.pragma;\r\n      let pragmaFragSet = !!options.pragmaFrag;\r\n\r\n      if (file.ast.comments) {\r\n        for (const comment of file.ast.comments) {\r\n          const jsxMatches = JSX_ANNOTATION_REGEX.exec(comment.value);\r\n          if (jsxMatches) {\r\n            pragma = jsxMatches[1];\r\n            pragmaSet = true;\r\n          }\r\n          const jsxFragMatches = JSX_FRAG_ANNOTATION_REGEX.exec(comment.value);\r\n          if (jsxFragMatches) {\r\n            pragmaFrag = jsxFragMatches[1];\r\n            pragmaFragSet = true;\r\n          }\r\n        }\r\n      }\r\n\r\n      state.set('jsxIdentifier', createIdentifierParser(pragma));\r\n      state.set('jsxFragIdentifier', createIdentifierParser(pragmaFrag));\r\n      state.set('usedFragment', false);\r\n      state.set('pragmaSet', pragmaSet);\r\n      state.set('pragmaFragSet', pragmaFragSet);\r\n    },\r\n    exit(path, state) {\r\n      if (\r\n        state.get('pragmaSet') &&\r\n        state.get('usedFragment') &&\r\n        !state.get('pragmaFragSet')\r\n      ) {\r\n        throw new Error(\r\n          'transform-react-jsx: pragma has been set but ' + 'pragmafrag has not been set',\r\n        );\r\n      }\r\n    },\r\n  };\r\n\r\n  visitor.JSXFragment = function(path) {\r\n    if (isRootJSXNode(path)) {\r\n      const outerPath = findProgramAndOuterPath(path).path;\r\n      const domNodes = [\r\n        ...yieldDomNodeFromJSXFragment(path.node, false, path.scope, outerPath),\r\n      ];\r\n      replacePathWithDomNodeSyntax(domNodes, path, outerPath);\r\n    }\r\n  };\r\n\r\n  visitor.JSXElement = {\r\n    exit(path) {\r\n      if (isRootJSXNode(path)) {\r\n        const outerPath = findProgramAndOuterPath(path).path;\r\n        const domNode = domNodeFromJSXElement(path.node, false, path.scope, outerPath);\r\n        replacePathWithDomNodeSyntax([domNode], path, outerPath);\r\n      }\r\n    },\r\n  };\r\n\r\n  return {\r\n    name: 'transform-react-jsx',\r\n    inherits: jsx,\r\n    visitor,\r\n  };\r\n});\r\n"],"file":"index.js"}