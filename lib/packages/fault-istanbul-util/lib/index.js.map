{"version":3,"sources":["../src/index.ts"],"names":["cloneCoverage","coverage","Array","isArray","map","obj","key","value","Object","entries","diffExpressionObjectCount","from","amount","diff","keys","diffBranchObjectCount","fromBranch","amountBranch","branch","length","i","notZero","subtractCoverage","undefined","filePath","fileCoverage","beforeFileCoverage","fileDiff","path","statementMap","fnMap","branchMap","s","f","b","_coverageSchema","hash","hasChanged","values","some","arr","readCoverageFile","coverageText","JSON","parse","getTotalExecutedStatements","total","filter"],"mappings":"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","sourcesContent":["import { readFile } from 'mz/fs';\r\n\r\nexport const cloneCoverage = coverage => {\r\n  if (Array.isArray(coverage)) {\r\n    return coverage.map(cloneCoverage);\r\n  } else if (typeof coverage === 'object') {\r\n    const obj = {};\r\n    for (const [key, value] of Object.entries(coverage)) {\r\n      obj[key] = cloneCoverage(value);\r\n    }\r\n    return obj;\r\n  } else {\r\n    return coverage;\r\n  }\r\n};\r\n\r\nexport const diffExpressionObjectCount = (from, amount) => {\r\n  const diff = {};\r\n  for (const key of Object.keys(from)) {\r\n    diff[key] = from[key] - amount[key];\r\n  }\r\n  return diff;\r\n};\r\n\r\nexport interface BCoverage {\r\n  [s: string]: number[];\r\n}\r\n\r\nexport const diffBranchObjectCount = (from: BCoverage, amount: BCoverage) => {\r\n  const diff: BCoverage = {};\r\n\r\n  for (const key of Object.keys(from)) {\r\n    const fromBranch = from[key];\r\n    const amountBranch = amount[key];\r\n\r\n    const branch = new Array(fromBranch.length);\r\n    for (let i = 0; i < branch.length; i++) {\r\n      branch[i] = fromBranch[i] - amountBranch[i];\r\n    }\r\n    diff[key] = branch;\r\n  }\r\n\r\n  return diff;\r\n};\r\n\r\nconst notZero = value => value !== 0;\r\n\r\nexport interface FCoverage {\r\n  [s: string]: number;\r\n}\r\n\r\nexport interface SCoverage {\r\n  [s: string]: number;\r\n}\r\n\r\nexport type TextLocation = {\r\n  line: number;\r\n  column: number;\r\n};\r\n\r\nexport interface ExpressionLocation {\r\n  start: TextLocation;\r\n  end: TextLocation;\r\n}\r\nexport interface StatementMap {\r\n  [s: string]: ExpressionLocation;\r\n}\r\nexport interface FunctionCoverage {\r\n  name: string;\r\n  decl: ExpressionLocation;\r\n  loc: ExpressionLocation;\r\n  line: number;\r\n}\r\nexport interface FunctionMap {\r\n  [s: string]: FunctionCoverage;\r\n}\r\nexport interface Coverage {\r\n  [s: string]: {\r\n    path: string;\r\n    statementMap: StatementMap;\r\n    fnMap: FunctionMap;\r\n    branchMap: any;\r\n    s: SCoverage;\r\n    f: FCoverage;\r\n    b: BCoverage;\r\n    _coverageSchema: string;\r\n    hash: string;\r\n  };\r\n}\r\nexport const subtractCoverage = (from: Coverage, amount: Coverage | undefined) => {\r\n  if (amount === undefined) {\r\n    return cloneCoverage(from);\r\n  }\r\n  const diff = {};\r\n  for (const [filePath, fileCoverage] of Object.entries(from)) {\r\n    const beforeFileCoverage = amount[filePath];\r\n    if (beforeFileCoverage === undefined) {\r\n      diff[filePath] = cloneCoverage(fileCoverage);\r\n      continue;\r\n    }\r\n\r\n    const fileDiff = {\r\n      path: filePath,\r\n      statementMap: fileCoverage.statementMap,\r\n      fnMap: fileCoverage.fnMap,\r\n      branchMap: fileCoverage.branchMap,\r\n      s: diffExpressionObjectCount(fileCoverage.s, beforeFileCoverage.s),\r\n      f: diffExpressionObjectCount(fileCoverage.f, beforeFileCoverage.f),\r\n      b: diffBranchObjectCount(fileCoverage.b, beforeFileCoverage.b),\r\n      _coverageSchema: fileCoverage._coverageSchema,\r\n      hash: fileCoverage.hash,\r\n    };\r\n\r\n    const hasChanged =\r\n      Object.values(fileDiff.s).some(notZero) ||\r\n      Object.values(fileDiff.f).some(notZero) ||\r\n      Object.values(fileDiff.b).some(arr => arr.some(notZero));\r\n    if (hasChanged) {\r\n      diff[filePath] = fileDiff;\r\n    }\r\n  }\r\n  return diff;\r\n};\r\n\r\nexport const readCoverageFile = async (\r\n  filePath: string = './coverage/coverage-final.json',\r\n): Promise<Coverage> => {\r\n  const coverageText = await readFile(filePath, 'utf8');\r\n  const coverage = JSON.parse(coverageText);\r\n  return coverage;\r\n};\r\n\r\nexport const getTotalExecutedStatements = (coverage: Coverage): number => {\r\n  let total = 0;\r\n\r\n  for (const fileCoverage of Object.values(coverage)) {\r\n    total += Object.values(fileCoverage.s).filter(value => value > 0).length;\r\n  }\r\n\r\n  return total;\r\n};\r\n"],"file":"index.js"}