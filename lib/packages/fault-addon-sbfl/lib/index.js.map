{"version":3,"sources":["../src/index.ts"],"names":["statementStr","filePath","start","end","line","column","gatherResults","testResults","expressionResults","Map","testResult","coverage","undefined","fileCoverage","Object","entries","statementMap","statementKey","keys","executionCount","s","statementCoverage","hash","results","has","get","passFailCounts","passed","failed","newResult","location","stats","testedPath","file","sourcePath","path","set","fileResults","expressionResult","values","expressions","fileResult","push","localizeFaults","groupedTestResults","scoringFn","faults","selectedSourceFiles","Set","add","expression","score","simplifyPath","absoluteFilePath","process","cwd","reportFaults","rankedFaults","filter","fault","sort","f1","f2","slice","lines","split","console","log","chalk","cyan","toString","l","lineCount","maxLineCount","grey","lastLine","spaces","match","Array","length","join","createPlugin","dStar","faultFilePath","on","complete","totalPassFailStats","expressionPassFailStats","resolvedFilePath"],"mappings":"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","sourcesContent":["import { TestResult, TesterResults } from '@fault/types';\r\nimport { ExpressionLocation } from '@fault/istanbul-util';\r\nimport { PartialTestHookOptions } from '@fault/addon-hook-schema';\r\nimport { passFailStatsFromTests } from '@fault/localization-util';\r\nimport { recordFaults } from '@fault/record-faults';\r\nimport dStar from '@fault/sbfl-dstar';\r\n\r\nimport { relative } from 'path';\r\nimport { readFile } from 'mz/fs';\r\nimport chalk from 'chalk';\r\n\r\nexport type Stats = {\r\n  passed: number;\r\n  failed: number;\r\n};\r\n\r\nexport type ExpressionResult = {\r\n  stats: Stats;\r\n  location: ExpressionLocation;\r\n  testedPath: string;\r\n  sourcePath: string;\r\n};\r\n\r\nexport type FileResult = {\r\n  testedPath: string;\r\n  sourcePath: string;\r\n  expressions: ExpressionResult[];\r\n};\r\n\r\nexport type ScorelessFault = {\r\n  location: ExpressionLocation;\r\n  testedPath: string;\r\n  sourcePath: string;\r\n};\r\n\r\nexport type Fault = {\r\n  score: number | null;\r\n} & ScorelessFault;\r\n\r\nconst statementStr = (filePath: string, { start, end }: ExpressionLocation) => {\r\n  return `${filePath}:${start.line}:${start.column}|${end.line}:${end.column}`;\r\n};\r\n\r\nexport const gatherResults = (testResults: Iterable<TestResult>) => {\r\n  const expressionResults: Map<string, ExpressionResult> = new Map();\r\n  for (const testResult of testResults) {\r\n    const coverage = testResult.coverage;\r\n    if (coverage === undefined) {\r\n      continue;\r\n    }\r\n    for (const [filePath, fileCoverage] of Object.entries(coverage) as any) {\r\n      const statementMap = fileCoverage.statementMap;\r\n      for (const statementKey of Object.keys(statementMap)) {\r\n        const executionCount = fileCoverage.s[statementKey];\r\n        if (executionCount === 0) {\r\n          continue;\r\n        }\r\n        const statementCoverage = statementMap[statementKey];\r\n        const hash = statementStr(filePath, statementCoverage);\r\n\r\n        const results = (() => {\r\n          if (expressionResults.has(hash)) {\r\n            return expressionResults.get(hash)!;\r\n          } else {\r\n            const passFailCounts = { passed: 0, failed: 0 };\r\n            const newResult: ExpressionResult = {\r\n              location: statementCoverage,\r\n              stats: passFailCounts,\r\n              testedPath: testResult.file,\r\n              sourcePath: fileCoverage.path,\r\n            };\r\n            expressionResults.set(hash, newResult);\r\n            return newResult;\r\n          }\r\n        })();\r\n        results.stats[testResult.passed ? 'passed' : 'failed']++;\r\n      }\r\n    }\r\n  }\r\n\r\n  const fileResults: Map<string, FileResult> = new Map();\r\n  for (const expressionResult of expressionResults.values()) {\r\n    const { sourcePath, testedPath } = expressionResult;\r\n    if (!fileResults.has(expressionResult.sourcePath)) {\r\n      fileResults.set(sourcePath, {\r\n        sourcePath,\r\n        testedPath,\r\n        expressions: [expressionResult],\r\n      });\r\n    } else {\r\n      const fileResult = fileResults.get(sourcePath)!;\r\n      fileResult.expressions.push(expressionResult);\r\n    }\r\n  }\r\n  return fileResults;\r\n};\r\n\r\ntype InternalScoringFn = (expressionPassFailStats: Stats) => number | null;\r\ntype ExternalScoringFn = (\r\n  expressionPassFailStats: Stats,\r\n  totalPassFailStats: Stats,\r\n) => number | null;\r\nexport type ScoringFn = ExternalScoringFn;\r\nexport const localizeFaults = (\r\n  groupedTestResults: Iterable<TestResult>,\r\n  fileResults: Map<string, FileResult>,\r\n  scoringFn: InternalScoringFn,\r\n): Fault[] => {\r\n  const faults: Fault[] = [];\r\n  const selectedSourceFiles: Set<string> = new Set();\r\n  for (const testResult of groupedTestResults) {\r\n    if (testResult.coverage === undefined) {\r\n      continue;\r\n    }\r\n    for (const coverage of Object.values(testResult.coverage)) {\r\n      selectedSourceFiles.add(coverage.path);\r\n    }\r\n  }\r\n  for (const sourcePath of selectedSourceFiles) {\r\n    const fileResult = fileResults.get(sourcePath)!;\r\n    for (const expression of fileResult.expressions) {\r\n      const { location, sourcePath, testedPath } = expression;\r\n      faults.push({\r\n        sourcePath,\r\n        testedPath,\r\n        location,\r\n        score: scoringFn(expression.stats),\r\n      });\r\n    }\r\n  }\r\n  return faults;\r\n};\r\n\r\nconst simplifyPath = absoluteFilePath => relative(process.cwd(), absoluteFilePath);\r\n\r\nconst reportFaults = async (faults: Fault[], scoringFn: ExternalScoringFn) => {\r\n  const rankedFaults = faults\r\n    .filter(fault => fault.score !== null)\r\n    .sort((f1, f2) => f2.score! - f1.score!)\r\n    .slice(0, 10);\r\n  for (const fault of rankedFaults) {\r\n    const lines = (await readFile(fault.sourcePath, 'utf8')).split('\\n');\r\n    console.log(\r\n      `${simplifyPath(fault.sourcePath)}:${fault.location.start.line}:${\r\n        fault.location.start.column\r\n      }, ${chalk.cyan(fault.score!.toString())}`,\r\n    );\r\n    let l = fault.location.start.line - 1;\r\n    let lineCount = 0;\r\n    const maxLineCount = 3;\r\n    while (l < fault.location.end.line - 1 && lineCount < maxLineCount) {\r\n      console.log(chalk.grey(lines[l++]));\r\n      lineCount++;\r\n    }\r\n    const lastLine = lines[l++];\r\n    console.log(chalk.grey(lastLine));\r\n    if (lineCount >= maxLineCount) {\r\n      const spaces = lastLine.match(/^ */)![0];\r\n      console.log(chalk.grey(`${new Array(spaces.length + 1).join(' ')}...`));\r\n    }\r\n    console.log();\r\n  }\r\n};\r\n\r\nexport type PluginOptions = {\r\n  scoringFn?: ScoringFn;\r\n  faultFilePath?: string | null | true | false;\r\n};\r\n\r\nexport const createPlugin = ({\r\n  scoringFn = dStar,\r\n  faultFilePath,\r\n}: PluginOptions): PartialTestHookOptions => {\r\n  return {\r\n    on: {\r\n      complete: async (results: TesterResults) => {\r\n        const testResults: TestResult[] = [...results.testResults.values()];\r\n        const fileResults = gatherResults(testResults);\r\n        const totalPassFailStats = passFailStatsFromTests(testResults);\r\n        const faults = localizeFaults(testResults, fileResults, expressionPassFailStats =>\r\n          scoringFn(expressionPassFailStats, totalPassFailStats),\r\n        );\r\n        await reportFaults(faults, scoringFn);\r\n        if (\r\n          faultFilePath !== null &&\r\n          faultFilePath !== undefined &&\r\n          faultFilePath !== false\r\n        ) {\r\n          const resolvedFilePath = (() => {\r\n            if (faultFilePath === true) {\r\n              return './faults/faults.json';\r\n            } else {\r\n              return faultFilePath;\r\n            }\r\n          })();\r\n          await recordFaults(resolvedFilePath, faults);\r\n        }\r\n      },\r\n    },\r\n  };\r\n};\r\n\r\nexport default createPlugin;\r\n"],"file":"index.js"}