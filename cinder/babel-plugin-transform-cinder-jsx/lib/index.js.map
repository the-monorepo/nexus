{"version":3,"sources":["../src/index.ts"],"names":["cinderMemberExpression","field","t","memberExpression","identifier","cinderCallExpression","functionName","args","callExpression","attributeLiteralToHTMLAttributeString","key","name","expression","literalPath","literal","node","isStringLiteral","isBooleanLiteral","value","isNumericLiteral","isBig","isTemplateLiteral","quasis","undefined","toString","TEXT_TYPE","DYNAMIC_TYPE","ELEMENT_TYPE","SUBCOMPONENT_TYPE","PROPERTY_TYPE","SPREAD_TYPE","EVENT_TYPE","ATTRIBUTE_TYPE","SUBCOMPONENT_PROPERTY_TYPE","api","options","assertVersion","domNodeFromJSXText","path","previousIsDynamic","scope","domNodeFromString","isElementTag","tag","toLowerCase","isLiteral","expressions","length","fieldType","match","findProgramAndOuterPath","parent","parentPath","program","result","isRootJSXNode","isJSXFragment","isJSXElement","isJSXExpressionContainer","cleanFieldName","replace","valueExpressionFromJsxAttributeValue","valuePath","current","get","domNodesFromJSXChildren","jsxChildrenPaths","outerPath","children","previousNode","childPath","yieldDomNodeFromNodeSimplified","isDynamicDomlessNode","push","hasDynamicNodes","some","childNode","type","id","domNodeFromJSXElement","jsxOpeningElementPath","jsxAttributePathsOrPath","jsxAttributePaths","Array","isArray","jsxOpeningElementNamePath","isJSXIdentifier","potentialId","generateUidIdentifier","fields","map","jsxAttributePath","isJSXSpreadAttribute","argumentPath","spreadExpressionPath","isJSXAttribute","namePath","isJSXNamespacedName","Error","setterId","setterMap","has","elementId","valueId","insertBefore","constDeclaration","arrowFunctionExpression","assignmentExpression","set","childrenAreDynamic","nonStaticAttributeFields","filter","resultNode","nameExpression","childrenTemplateId","aString","html","text","yieldDomNodeFromJSXFragment","yieldDomNodeFromJSXExpressionContainerNode","expressionPath","textNode","yieldDomNodeFromNodeNonSimplified","isJSXText","domNodeIterator","firstIteration","next","done","previous","htmlFromNode","attributeString","join","childrenString","variableDeclaration","variableDeclarator","STATIC_ELEMENT_TEMPLATE_FACTORY_NAME","DYNAMIC_ELEMENT_TEMPLATE_FACTORY_NAME","STATIC_FRAGMENT_TEMPLATE_FACTORY_NAME","DYNAMIC_FRAGMENT_TEMPLATE_FACTORY_NAME","yieldDeclarationStatementsFromRootNodes","nodes","rootId","isRoot","childrenWithDomNodesAssociatedWithThem","child","c","generateDeclaredUidIdentifier","firstNode","expressionStatement","numericLiteral","lastNode","previousId","dynamicFieldExpression","beforeId","previousConsecutiveDynamicNodeCount","yieldFieldExpressionsFromNodes","dynamicExpression","stringLiteral","yieldFieldValuesFromNode","objectProperties","spreadElement","objectProperty","fieldValues","domChildren","nodeHasDom","arrayExpression","objectExpression","yieldTemplateInfoFromRootNodes","templateId","nodeStack","pop","reverse","nodesWithDom","isDynamicChildren","templateMethod","rootParamId","statements","fieldExpressions","returnStatement","blockStatement","arrowFunction","replacePathWithDomNodeSyntax","templateDeclarations","statement","componentResultArgs","replaceWith","nodeFieldValues","THROW_IF_NAMESPACE","throwIfNamespace","PRAGMA_DEFAULT","pragma","PRAGMA_FRAG_DEFAULT","pragmaFrag","JSX_ANNOTATION_REGEX","JSX_FRAG_ANNOTATION_REGEX","createIdentifierParser","identifiers","split","cur","i","visitor","pre","state","tagName","core","types","react","isCompatTag","tagExpr","post","pass","callee","Program","enter","Map","file","pragmaSet","pragmaFragSet","ast","comments","comment","jsxMatches","exec","jsxFragMatches","exit","JSXFragment","findParent","isProgram","domNodes","JSXElement","domNode","inherits","jsx"],"mappings":"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","sourcesContent":["import * as core from '@babel/core';\nimport helper from '@babel/helper-builder-react-jsx';\nimport { declare } from '@babel/helper-plugin-utils';\nimport jsx from '@babel/plugin-syntax-jsx';\nimport * as tr from '@babel/traverse';\nimport { JSXElement, JSXText } from '@babel/types';\nimport * as t from '@babel/types';\nimport { JSXExpressionContainer } from '@babel/types';\n\nconst cinderMemberExpression = (field: string) => {\n  return t.memberExpression(t.identifier('cinder'), t.identifier(field));\n};\n\nconst cinderCallExpression = (\n  functionName: string,\n  args: Parameters<typeof t.callExpression>[1],\n) => {\n  return t.callExpression(cinderMemberExpression(functionName), args);\n};\n\nconst attributeLiteralToHTMLAttributeString = (field: LiteralAttributeField) => {\n  const { key: name, expression: literalPath } = field;\n  // TODO: Refactor\n  const literal = literalPath.node;\n\n  if (literal === null) {\n    // This is like <element attrName/>\n    return `${name}`;\n  }\n  if (literalPath.isStringLiteral()) {\n    return `${name}=${literalPath}`;\n  } else if (literalPath.isBooleanLiteral()) {\n    return literalPath.node.value ? name : '';\n  } else if (literalPath.isNumericLiteral() || literalPath.isBig) {\n    return `${name}=\"${literalPath.node.value}\"`;\n  } else if (literalPath.isTemplateLiteral()) {\n    return literalPath.node.quasis[0];\n  } else if (literal.value !== undefined) {\n    return `${name}=${literalPath.node.value.toString()}`;\n  }\n};\n\nconst TEXT_TYPE = 'text';\nconst DYNAMIC_TYPE = 'dynamic';\nconst ELEMENT_TYPE = 'element';\nconst SUBCOMPONENT_TYPE = 'subcomponent';\n\nconst PROPERTY_TYPE = 'property';\nconst SPREAD_TYPE = 'spread';\nconst EVENT_TYPE = 'event';\nconst ATTRIBUTE_TYPE = 'attribute';\n\ntype JSXChildrenNode =\n  | t.JSXText\n  | t.JSXExpressionContainer\n  | t.JSXSpreadChild\n  | t.JSXElement\n  | t.JSXFragment;\n\ntype PropertyField = {\n  type: typeof PROPERTY_TYPE;\n  key: string;\n  expression: tr.NodePath<\n    Exclude<\n      t.JSXAttribute['value'] | t.JSXExpressionContainer['expression'],\n      t.JSXExpressionContainer\n    >\n  >;\n  setterId: any;\n};\n\ntype SpreadField = {\n  type: typeof SPREAD_TYPE;\n  expression: tr.NodePath<t.JSXSpreadAttribute['argument']>;\n};\n\ntype EventField = {\n  type: typeof EVENT_TYPE;\n  key: string;\n  expression: tr.NodePath<\n    Exclude<\n      t.JSXAttribute['value'] | t.JSXExpressionContainer['expression'],\n      t.JSXExpressionContainer\n    >\n  >;\n};\n\ntype DynamicAttributeField = {\n  type: typeof ATTRIBUTE_TYPE;\n  key: string;\n  expression: tr.NodePath<\n    Exclude<\n      t.JSXAttribute['value'] | t.JSXExpressionContainer['expression'],\n      t.JSXExpressionContainer\n    >\n  >;\n};\n\ntype LiteralAttributeField = {\n  type: typeof ATTRIBUTE_TYPE;\n  key: string;\n  expression: tr.NodePath<Exclude<t.Literal, t.JSXAttribute['value']>>;\n};\n\ntype AttributeField = DynamicAttributeField | LiteralAttributeField;\n\ntype ElementField = AttributeField | PropertyField | EventField | SpreadField; // TODO: SpreadType\n\n/**\n * We have no idea how many node will be in this section.\n * Could be 0, could be 100\n */\ntype DynamicSection = {\n  type: typeof DYNAMIC_TYPE;\n  expression: tr.NodePath;\n};\n/**\n * Just a typical HTML/XML element\n */\ntype ElementNode = {\n  type: typeof ELEMENT_TYPE;\n  tag: string;\n  children: Node[];\n  fields: ElementField[];\n  id: t.Identifier | null;\n};\n\nconst SUBCOMPONENT_PROPERTY_TYPE = 'subcomponent_property';\ntype SubcomponentPropertyField = {\n  type: typeof SUBCOMPONENT_PROPERTY_TYPE;\n  key: string;\n  expression: tr.NodePath<t.Expression | null>;\n};\n\ntype SubcomponentField = SubcomponentPropertyField | SpreadField;\n\n/**\n * Represents things like:\n * <Subcomponent><child>...</child>...</SubComponent>\n * Note that this is similar to a DynamicSection in that we have\n * no idea how many root nodes the subcomponent represents:\n * Could be 0, could 100\n */\ntype SubcomponentNode = {\n  type: typeof SUBCOMPONENT_TYPE;\n  nameExpression: tr.NodePath<t.JSXOpeningElement['name']>; // TODO\n  children: Node[];\n  childrenTemplateId: t.Identifier | null;\n  fields: SubcomponentField[];\n};\n\n/**\n * Just a text node\n */\ntype TextNode = {\n  type: typeof TEXT_TYPE;\n  text: string;\n  id: t.Identifier | null;\n};\n\ntype Node = DynamicSection | ElementNode | TextNode | SubcomponentNode;\n\nexport default declare((api, options) => {\n  api.assertVersion(7);\n\n  function domNodeFromJSXText(\n    path: tr.NodePath<JSXText>,\n    previousIsDynamic: boolean,\n    scope,\n  ) {\n    return domNodeFromString(path.node.value, previousIsDynamic, scope);\n  }\n\n  const isElementTag = (tag: string) => {\n    return tag[0].toLowerCase() === tag[0];\n  };\n\n  const isLiteral = (value: tr.NodePath<any>): boolean => {\n    return (\n      value.node !== undefined &&\n      value.node !== null &&\n      value.isLiteral() &&\n      (!value.isTemplateLiteral() || value.node.expressions.length <= 0)\n    );\n  };\n\n  /*const isStatic = value => {\n    return (\n      value &&\n      (isLiteral(value) ||\n        t.isArrowFunctionExpression(value) ||\n        t.isFunctionExpression(value))\n    );\n  };*/\n\n  const fieldType = (name: string) => {\n    return name.match(/^\\$\\$/)\n      ? EVENT_TYPE\n      : name.match(/^\\$/)\n      ? PROPERTY_TYPE\n      : ATTRIBUTE_TYPE;\n  };\n\n  const findProgramAndOuterPath = (path: tr.NodePath) => {\n    const parent = path.parentPath;\n    if (!parent) {\n      return { program: path };\n    } else {\n      const result = findProgramAndOuterPath(parent);\n      if (result.path) {\n        return result;\n      } else {\n        return { program: result.program, path: path };\n      }\n    }\n  };\n\n  const isRootJSXNode = (path: tr.NodePath) => {\n    const parent = path.parentPath;\n\n    if (parent.isJSXFragment() || parent.isJSXElement()) {\n      return false;\n    } else if (parent.isJSXExpressionContainer()) {\n      // TODO: Very confusing condition\n      return isRootJSXNode(parent);\n    } else {\n      return true;\n    }\n  };\n\n  const cleanFieldName = (name: string) => name.replace(/^\\$?\\$?/, '');\n\n  const valueExpressionFromJsxAttributeValue = (\n    valuePath: tr.NodePath<t.JSXAttribute['value']>,\n  ): tr.NodePath<\n    | t.JSXAttribute['value']\n    | Exclude<t.JSXExpressionContainer['expression'], t.JSXExpressionContainer>\n  > => {\n    let current: tr.NodePath<\n      t.JSXAttribute['value'] | t.JSXExpressionContainer['expression']\n    > = valuePath;\n    while (current.isJSXExpressionContainer()) {\n      current = valuePath.get('expression');\n    }\n    return current as any;\n  };\n\n  const domNodesFromJSXChildren = (\n    jsxChildrenPaths: tr.NodePath<JSXChildrenNode>[],\n    scope: tr.Scope,\n    outerPath: tr.NodePath,\n  ) => {\n    const children: Node[] = [];\n    let previousNode: Node | null = null;\n    for (const childPath of jsxChildrenPaths) {\n      for (const node of yieldDomNodeFromNodeSimplified(\n        childPath,\n        previousNode !== null && isDynamicDomlessNode(previousNode),\n        scope,\n        outerPath,\n      )) {\n        previousNode = node;\n        children.push(node);\n      }\n    }\n    return children;\n  };\n\n  const hasDynamicNodes = (children: Node[]) => {\n    return children.some(\n      (childNode) =>\n        childNode.type === DYNAMIC_TYPE ||\n        (childNode.type === ELEMENT_TYPE && childNode.id) ||\n        SUBCOMPONENT_TYPE,\n    );\n  };\n\n  const domNodeFromJSXElement = (\n    path: tr.NodePath<JSXElement>,\n    previousIsDynamic: boolean,\n    scope: tr.Scope,\n    outerPath: tr.NodePath,\n  ): SubcomponentNode | ElementNode => {\n    const jsxOpeningElementPath = path.get('openingElement');\n    const jsxAttributePathsOrPath = jsxOpeningElementPath.get('attributes');\n    const jsxAttributePaths = Array.isArray(jsxAttributePathsOrPath)\n      ? jsxAttributePathsOrPath\n      : [jsxAttributePathsOrPath];\n    const jsxOpeningElementNamePath = jsxOpeningElementPath.get('name');\n    if (\n      jsxOpeningElementNamePath.isJSXIdentifier() &&\n      isElementTag(jsxOpeningElementNamePath.node.name)\n    ) {\n      const tag = jsxOpeningElementNamePath.node.name;\n      const potentialId = scope.generateUidIdentifier(`${tag}$`);\n      const fields: ElementField[] = jsxAttributePaths.map(\n        (jsxAttributePath): ElementField => {\n          if (jsxAttributePath.isJSXSpreadAttribute()) {\n            const argumentPath = jsxAttributePath.get('argument');\n            const spreadExpressionPath = valueExpressionFromJsxAttributeValue(\n              argumentPath,\n            );\n            return {\n              type: SPREAD_TYPE,\n              expression: spreadExpressionPath,\n            };\n          } else if (jsxAttributePath.isJSXAttribute()) {\n            const namePath = jsxAttributePath.get('name');\n            const valuePath = jsxAttributePath.get('value');\n            if (namePath.isJSXNamespacedName()) {\n              throw new Error('Not supported');\n            } else if (namePath.isJSXIdentifier()) {\n              const type = fieldType(namePath.node.name);\n              switch (type) {\n                case PROPERTY_TYPE:\n                  const key = cleanFieldName(namePath.node.name);\n                  const setterId = (() => {\n                    if (setterMap.has(key)) {\n                      return setterMap.get(key)!;\n                    } else {\n                      const id = outerPath.scope.generateUidIdentifier(`${key}$setter`);\n                      const elementId = outerPath.scope.generateUidIdentifier('element');\n                      const valueId = outerPath.scope.generateUidIdentifier('value');\n\n                      outerPath.insertBefore(\n                        constDeclaration(\n                          id,\n                          t.arrowFunctionExpression(\n                            [elementId, valueId],\n                            t.assignmentExpression(\n                              '=',\n                              t.memberExpression(elementId, t.identifier(key)),\n                              valueId,\n                            ),\n                          ),\n                        ),\n                      );\n                      setterMap.set(key, id);\n                      return id;\n                    }\n                  })();\n                  return {\n                    type,\n                    setterId,\n                    expression: valueExpressionFromJsxAttributeValue(valuePath),\n                    key,\n                  };\n                default:\n                  return {\n                    type,\n                    key: cleanFieldName(namePath.node.name),\n                    expression: valueExpressionFromJsxAttributeValue(valuePath),\n                  } as ElementField;\n              }\n            }\n          }\n          throw new Error('Not supported');\n        },\n      );\n      const children = domNodesFromJSXChildren(path.get('children'), scope, outerPath);\n      const childrenAreDynamic = hasDynamicNodes(children);\n      const nonStaticAttributeFields = fields.filter(\n        (field) => !(field.type === ATTRIBUTE_TYPE && isLiteral(field.expression)),\n      );\n      const resultNode: ElementNode = {\n        type: ELEMENT_TYPE,\n        tag,\n        children,\n        fields,\n        id:\n          previousIsDynamic || childrenAreDynamic || nonStaticAttributeFields.length > 0\n            ? potentialId\n            : null,\n      };\n      return resultNode;\n    } else {\n      const fields: SubcomponentField[] = jsxAttributePaths.map(\n        (jsxAttributePath): SubcomponentField => {\n          if (jsxAttributePath.isJSXSpreadAttribute()) {\n            const result: SpreadField = {\n              type: SPREAD_TYPE,\n              expression: jsxAttributePath.get('argument'), // TODO: Check this is right\n            };\n            return result;\n          } else if (jsxAttributePath.isJSXAttribute()) {\n            const namePath = jsxAttributePath.get('name');\n            if (namePath.isJSXNamespacedName()) {\n              throw new Error('Not supported');\n            } else if (namePath.isJSXIdentifier()) {\n              const result: SubcomponentPropertyField = {\n                type: SUBCOMPONENT_PROPERTY_TYPE,\n                key: namePath.node.name,\n                expression: valueExpressionFromJsxAttributeValue(\n                  jsxAttributePath.get('value'),\n                ),\n              };\n              return result;\n            }\n          }\n          throw new Error('Not supported');\n        },\n      );\n      const children = domNodesFromJSXChildren(path.get('children'), scope, outerPath);\n\n      const resultNode: SubcomponentNode = {\n        type: SUBCOMPONENT_TYPE,\n        nameExpression: jsxOpeningElementPath.get('name'),\n        children,\n        childrenTemplateId:\n          children.length > 0 ? scope.generateUidIdentifier('subTemplate') : null,\n        fields,\n      };\n      return resultNode;\n    }\n  };\n\n  const domNodeFromString = (\n    aString: string,\n    previousIsDynamic: boolean,\n    scope: tr.Scope,\n  ): TextNode | null => {\n    const html = aString.replace(/^\\s*\\n\\s*|\\s*\\n\\s*$/g, '');\n    if (html === '') {\n      return null;\n    }\n    return {\n      type: TEXT_TYPE,\n      text: html,\n      // TODO: We could probably do id assignment post DOM node tree collection\n      id: previousIsDynamic ? scope.generateUidIdentifier('text') : null,\n    };\n  };\n\n  const isDynamicDomlessNode = (node: Node) => {\n    return node.type === DYNAMIC_TYPE || node.type === SUBCOMPONENT_TYPE;\n  };\n\n  function* yieldDomNodeFromJSXFragment(\n    path: tr.NodePath<t.JSXFragment>,\n    previousIsDynamic: boolean,\n    scope,\n    outerPath,\n  ) {\n    for (const childPath of path.get('children')) {\n      for (const node of yieldDomNodeFromNodeSimplified(\n        childPath,\n        previousIsDynamic,\n        scope,\n        outerPath,\n      )) {\n        previousIsDynamic = isDynamicDomlessNode(node);\n        yield node;\n      }\n    }\n  }\n\n  function* yieldDomNodeFromJSXExpressionContainerNode(\n    path: tr.NodePath<JSXExpressionContainer>,\n    previousIsDynamic: boolean,\n    scope,\n    outerPath,\n  ): IterableIterator<Node> {\n    const expressionPath = path.get('expression');\n    // TODO: Function and array literals\n    if (expressionPath.isJSXElement() || expressionPath.isJSXFragment()) {\n      yield* yieldDomNodeFromNodeSimplified(\n        expressionPath,\n        previousIsDynamic,\n        scope,\n        outerPath,\n      );\n    } else if (expressionPath.isStringLiteral()) {\n      // TODO: Two contained literals next to each other would lead to incorrect state length\n      const textNode = domNodeFromString(\n        expressionPath.node.value,\n        previousIsDynamic,\n        scope,\n      );\n      if (textNode) {\n        yield textNode;\n      }\n    } else if (expressionPath.isNumericLiteral() || expressionPath.isBooleanLiteral()) {\n      const textNode = domNodeFromString(\n        expressionPath.node.value.toString(),\n        previousIsDynamic,\n        scope,\n      );\n      if (textNode) {\n        yield textNode;\n      }\n    } else {\n      yield {\n        type: DYNAMIC_TYPE,\n        expression: expressionPath,\n      };\n    }\n  }\n\n  function* yieldDomNodeFromNodeNonSimplified(\n    path: tr.NodePath<JSXElement['children'][0]>,\n    previousIsDynamic,\n    scope,\n    outerPath,\n  ): IterableIterator<Node> {\n    if (path.isJSXElement()) {\n      yield domNodeFromJSXElement(path, previousIsDynamic, scope, outerPath);\n    } else if (path.isJSXExpressionContainer()) {\n      yield* yieldDomNodeFromJSXExpressionContainerNode(\n        path,\n        previousIsDynamic,\n        scope,\n        outerPath,\n      );\n    } else if (path.isJSXFragment()) {\n      yield* yieldDomNodeFromJSXFragment(path, previousIsDynamic, scope, outerPath);\n    } else if (path.isJSXText()) {\n      const textNode = domNodeFromJSXText(path, previousIsDynamic, scope);\n      if (textNode) {\n        yield textNode;\n      }\n    } else {\n      throw new Error(`Invalid node type ${path.node.type}`);\n    }\n  }\n\n  function* yieldDomNodeFromNodeSimplified(\n    path: tr.NodePath<JSXChildrenNode>,\n    previousIsDynamic: boolean,\n    scope,\n    outerPath,\n  ): IterableIterator<Node> {\n    const domNodeIterator = yieldDomNodeFromNodeNonSimplified(\n      path,\n      previousIsDynamic,\n      scope,\n      outerPath,\n    );\n    const firstIteration = domNodeIterator.next();\n    if (firstIteration.done) {\n      return;\n    }\n    let previous: Node = firstIteration.value;\n    for (const current of domNodeIterator) {\n      if (previous.type === TEXT_TYPE) {\n        if (current.type === TEXT_TYPE) {\n          previous.text += current.text;\n        } else {\n          yield previous;\n        }\n      } else {\n        yield previous;\n      }\n      previous = current;\n    }\n    yield previous;\n  }\n\n  const htmlFromNode = (node: Node): string => {\n    switch (node.type) {\n      case ELEMENT_TYPE:\n        const tag: string = node.tag;\n        const attributeString: string = (node.fields.filter(\n          (field) => field.type === ATTRIBUTE_TYPE && isLiteral(field.expression),\n        ) as AttributeField[])\n          .map((field) => attributeLiteralToHTMLAttributeString(field))\n          .join(' ');\n        const childrenString: string = node.children\n          .map((field) => {\n            return htmlFromNode(field);\n          })\n          .join('');\n        return `<${tag}${\n          attributeString !== '' ? ` ${attributeString}` : ''\n        }>${childrenString}</${tag}>`;\n      case TEXT_TYPE:\n        return node.text;\n      default:\n        return '';\n    }\n  };\n\n  const constDeclaration = (id, expression) => {\n    return t.variableDeclaration('const', [t.variableDeclarator(id, expression)]);\n  };\n\n  const STATIC_ELEMENT_TEMPLATE_FACTORY_NAME = 'staticElementBlueprint';\n  const DYNAMIC_ELEMENT_TEMPLATE_FACTORY_NAME = 'elementBlueprint';\n  const STATIC_FRAGMENT_TEMPLATE_FACTORY_NAME = 'staticFragmentBlueprint';\n  const DYNAMIC_FRAGMENT_TEMPLATE_FACTORY_NAME = 'fragmentBlueprint';\n\n  function* yieldDeclarationStatementsFromRootNodes(\n    nodes: Node[],\n    rootId: any,\n    isRoot: boolean,\n    scope: tr.Scope,\n  ) {\n    const childrenWithDomNodesAssociatedWithThem: (\n      | ElementNode\n      | TextNode\n    )[] = nodes.filter(\n      (child) => child.type === ELEMENT_TYPE || child.type === TEXT_TYPE,\n    ) as (ElementNode | TextNode)[];\n    if (childrenWithDomNodesAssociatedWithThem.length > 0) {\n      for (let c = 1; c < childrenWithDomNodesAssociatedWithThem.length - 1; c++) {\n        const previous = childrenWithDomNodesAssociatedWithThem[c - 1];\n        const current = childrenWithDomNodesAssociatedWithThem[c];\n        if (previous.type === TEXT_TYPE && current.type === TEXT_TYPE) {\n          if (previous.id === null) {\n            // Need this to split text up when there's 2 text nodes next to each other in the blueprint\n            previous.id = scope.generateDeclaredUidIdentifier('partialText');\n          }\n        }\n      }\n\n      const firstNode = childrenWithDomNodesAssociatedWithThem[0];\n      if (firstNode.id) {\n        if (isRoot && nodes.length === 1) {\n          yield constDeclaration(firstNode.id, rootId);\n        } else {\n          yield constDeclaration(\n            firstNode.id,\n            t.memberExpression(rootId, t.identifier('firstChild')),\n          );\n        }\n        if (firstNode.type === ELEMENT_TYPE) {\n          yield* yieldDeclarationStatementsFromRootNodes(\n            firstNode.children,\n            firstNode.id,\n            false,\n            scope,\n          );\n        }\n      }\n      for (let c = 1; c < childrenWithDomNodesAssociatedWithThem.length - 1; c++) {\n        const childNode = childrenWithDomNodesAssociatedWithThem[c];\n        if (childNode.id) {\n          const previousNode = childrenWithDomNodesAssociatedWithThem[c - 1];\n          if (previousNode.type === TEXT_TYPE && childNode.type === TEXT_TYPE) {\n            yield t.expressionStatement(\n              t.callExpression(\n                t.memberExpression(previousNode.id!, t.identifier('splitText')),\n                [t.numericLiteral(previousNode.text.length)],\n              ),\n            );\n          }\n          if (previousNode.id) {\n            yield constDeclaration(\n              childNode.id,\n              t.memberExpression(previousNode.id, t.identifier('nextSibling')),\n            );\n          } else {\n            yield constDeclaration(\n              childNode.id,\n              t.memberExpression(\n                t.memberExpression(rootId, t.identifier('childNodes')),\n                t.numericLiteral(c),\n                true,\n              ),\n            );\n          }\n          if (childNode.type === ELEMENT_TYPE) {\n            yield* yieldDeclarationStatementsFromRootNodes(\n              childNode.children,\n              childNode.id,\n              false,\n              scope,\n            );\n          }\n        }\n      }\n      // TODO: Could do previousSibling if the last node uses lastChild\n      if (childrenWithDomNodesAssociatedWithThem.length >= 2) {\n        const lastNode =\n          childrenWithDomNodesAssociatedWithThem[\n            childrenWithDomNodesAssociatedWithThem.length - 1\n          ];\n        if (lastNode.id) {\n          const previousNode =\n            childrenWithDomNodesAssociatedWithThem[\n              childrenWithDomNodesAssociatedWithThem.length - 2\n            ];\n          if (previousNode.type === TEXT_TYPE && lastNode.type === TEXT_TYPE) {\n            const previousId =\n              childrenWithDomNodesAssociatedWithThem.length === 2\n                ? t.identifier('firstChild')\n                : previousNode.id!;\n            yield t.expressionStatement(\n              t.callExpression(\n                t.memberExpression(previousId, t.identifier('splitText')),\n                [t.numericLiteral(previousNode.text.length)],\n              ),\n            );\n          }\n          yield constDeclaration(\n            lastNode.id,\n            t.memberExpression(rootId, t.identifier('lastChild')),\n          );\n          if (lastNode.type === ELEMENT_TYPE) {\n            yield* yieldDeclarationStatementsFromRootNodes(\n              lastNode.children,\n              lastNode.id,\n              false,\n              scope,\n            );\n          }\n        }\n      }\n    }\n  }\n\n  const dynamicFieldExpression = (\n    rootId,\n    beforeId,\n    previousConsecutiveDynamicNodeCount: number,\n  ) => {\n    if (previousConsecutiveDynamicNodeCount === 1) {\n      return cinderCallExpression('children', [rootId, beforeId]);\n    } else if (previousConsecutiveDynamicNodeCount >= 2) {\n      return cinderCallExpression('dynamicSection', [\n        rootId,\n        beforeId,\n        t.numericLiteral(previousConsecutiveDynamicNodeCount),\n      ]);\n    }\n    return null;\n  };\n\n  function* yieldFieldExpressionsFromNodes(nodes: Node[], rootId: t.Identifier) {\n    let previousConsecutiveDynamicNodeCount = 0;\n    for (const node of nodes) {\n      switch (node.type) {\n        case TEXT_TYPE:\n        case ELEMENT_TYPE:\n          const dynamicExpression = dynamicFieldExpression(\n            rootId,\n            node.id,\n            previousConsecutiveDynamicNodeCount,\n          );\n          if (dynamicExpression !== null) {\n            yield dynamicExpression;\n          }\n          previousConsecutiveDynamicNodeCount = 0;\n          if (node.type === ELEMENT_TYPE) {\n            for (const field of node.fields) {\n              switch (field.type) {\n                case EVENT_TYPE:\n                case ATTRIBUTE_TYPE:\n                  if (!isLiteral(field.expression)) {\n                    if (node.id === null) {\n                      throw new Error('Not supported');\n                    }\n\n                    yield cinderCallExpression(field.type, [\n                      node.id,\n                      t.stringLiteral(field.key),\n                    ]);\n                  }\n                  break;\n                case PROPERTY_TYPE:\n                  yield cinderCallExpression(field.type, [node.id, field.setterId]);\n                  break;\n                case SPREAD_TYPE:\n                  yield cinderCallExpression(field.type, [node.id]);\n                  break;\n                default:\n                  throw new Error(`Not supported: ${field.type}`);\n              }\n            }\n            if (node.id !== null) {\n              yield* yieldFieldExpressionsFromNodes(node.children, node.id);\n            }\n          }\n          break;\n        case SUBCOMPONENT_TYPE:\n        case DYNAMIC_TYPE:\n          previousConsecutiveDynamicNodeCount++;\n          break;\n      }\n    }\n    const dynamicExpression = dynamicFieldExpression(\n      rootId,\n      t.identifier('null'),\n      previousConsecutiveDynamicNodeCount,\n    );\n    if (dynamicExpression !== null) {\n      yield dynamicExpression;\n    }\n  }\n\n  function* yieldFieldValuesFromNode(node: Node): Generator<t.Node | null> {\n    switch (node.type) {\n      case ELEMENT_TYPE:\n        for (const field of node.fields) {\n          switch (field.type) {\n            case ATTRIBUTE_TYPE:\n              if (!isLiteral(field.expression)) {\n                yield field.expression.node;\n              }\n              break;\n            default:\n              yield field.expression.node;\n          }\n        }\n        for (const childNode of node.children) {\n          yield* yieldFieldValuesFromNode(childNode);\n        }\n        break;\n      case DYNAMIC_TYPE:\n        yield node.expression.node;\n        break;\n      case SUBCOMPONENT_TYPE:\n        const objectProperties: any[] = [];\n        for (const field of node.fields) {\n          switch (field.type) {\n            case SPREAD_TYPE:\n              objectProperties.push(t.spreadElement(field.expression.node));\n              break;\n            case SUBCOMPONENT_PROPERTY_TYPE:\n              if (field.expression.node === null) {\n                throw new Error('Not supported');\n              }\n              objectProperties.push(\n                t.objectProperty(t.identifier(field.key), field.expression.node),\n              );\n              break;\n          }\n        }\n        if (node.childrenTemplateId) {\n          const fieldValues: Parameters<typeof t.callExpression>[1] = [];\n          for (const childNode of node.children) {\n            fieldValues.push(...yieldFieldValuesFromNode(childNode));\n          }\n          const domChildren = node.children.filter(nodeHasDom);\n          if (domChildren.length > 0) {\n            objectProperties.push(\n              t.objectProperty(\n                t.identifier('children'),\n                cinderCallExpression('componentResult', [\n                  node.childrenTemplateId,\n                  t.arrayExpression([...fieldValues]),\n                ]),\n              ),\n            );\n          } else if (fieldValues.length > 0) {\n            objectProperties.push(\n              t.objectProperty(\n                t.identifier('children'),\n                fieldValues.length === 1\n                  ? fieldValues[0]\n                  : t.arrayExpression([...fieldValues]),\n              ),\n            );\n          }\n        }\n        // TODO: This whole block of code assumes that it's a SFC and not a string (representing an HTML element)\n        if (!node.nameExpression.isJSXIdentifier()) {\n          throw new Error('Not supported');\n        }\n        yield t.callExpression(t.identifier(node.nameExpression.node.name), [\n          t.objectExpression(objectProperties),\n        ]);\n    }\n  }\n\n  const nodeHasDom = (node: Node) =>\n    node.type === ELEMENT_TYPE || node.type === TEXT_TYPE;\n\n  function* yieldTemplateInfoFromRootNodes(nodes: Node[], templateId, scope) {\n    const nodeStack: Node[] = [...nodes];\n    while (nodeStack.length > 0) {\n      const node = nodeStack.pop()!;\n      switch (node.type) {\n        case SUBCOMPONENT_TYPE:\n          if (node.childrenTemplateId !== null) {\n            yield* yieldTemplateInfoFromRootNodes(\n              node.children,\n              node.childrenTemplateId,\n              scope,\n            );\n          } else {\n            nodeStack.push(...[...node.children].reverse());\n          }\n          break;\n        case ELEMENT_TYPE:\n          nodeStack.push(...[...node.children].reverse());\n          break;\n      }\n    }\n\n    const nodesWithDom: (ElementNode | TextNode)[] = nodes.filter(nodeHasDom) as (\n      | ElementNode\n      | TextNode\n    )[];\n    const isDynamicChildren = hasDynamicNodes(nodes);\n    const args: Parameters<typeof t.callExpression>[1] = [\n      t.stringLiteral(nodes.map((node) => htmlFromNode(node)).join('')),\n    ];\n    let templateMethod: string;\n    if (nodesWithDom.length <= 0) {\n      return;\n    } else if (nodes.length === 1) {\n      if (isDynamicChildren) {\n        templateMethod = DYNAMIC_ELEMENT_TEMPLATE_FACTORY_NAME;\n      } else {\n        templateMethod = STATIC_ELEMENT_TEMPLATE_FACTORY_NAME;\n      }\n    } else {\n      if (isDynamicChildren) {\n        templateMethod = DYNAMIC_FRAGMENT_TEMPLATE_FACTORY_NAME;\n      } else {\n        templateMethod = STATIC_FRAGMENT_TEMPLATE_FACTORY_NAME;\n      }\n    }\n    if (isDynamicChildren) {\n      const rootParamId = scope.generateUidIdentifier('rootNode');\n      const statements = [\n        ...yieldDeclarationStatementsFromRootNodes(nodes, rootParamId, true, scope),\n      ];\n      const fieldExpressions = [...yieldFieldExpressionsFromNodes(nodes, rootParamId)];\n      statements.push(t.returnStatement(t.arrayExpression(fieldExpressions)));\n\n      const blockStatement = t.blockStatement(statements);\n      const arrowFunction = t.arrowFunctionExpression([rootParamId], blockStatement);\n      args.push(arrowFunction);\n    }\n    yield constDeclaration(templateId, cinderCallExpression(templateMethod, args));\n  }\n\n  const replacePathWithDomNodeSyntax = (\n    nodes: Node[],\n    path: tr.NodePath,\n    outerPath: tr.NodePath,\n  ) => {\n    const templateId = path.scope.generateUidIdentifier('template');\n    const templateDeclarations = yieldTemplateInfoFromRootNodes(\n      nodes,\n      templateId,\n      path.scope,\n    );\n    for (const statement of templateDeclarations) {\n      outerPath.insertBefore(statement);\n    }\n    const nodesWithDom = nodes.filter(nodeHasDom);\n    if (nodesWithDom.length <= 0) {\n      const componentResultArgs: any[] = [];\n      for (const node of nodes) {\n        componentResultArgs.push(...yieldFieldValuesFromNode(node));\n      }\n      path.replaceWith(\n        t.expressionStatement(\n          componentResultArgs.length === 1\n            ? componentResultArgs[0]\n            : t.arrayExpression(componentResultArgs),\n        ),\n      );\n    } else {\n      const fieldValues: Parameters<typeof t.callExpression>[1] = [];\n      for (const node of nodes) {\n        const nodeFieldValues = yieldFieldValuesFromNode(node);\n        fieldValues.push(...nodeFieldValues);\n      }\n      path.replaceWith(\n        t.expressionStatement(\n          cinderCallExpression('componentResult', [\n            templateId,\n            t.arrayExpression(fieldValues),\n          ]),\n        ),\n      );\n    }\n  };\n\n  const THROW_IF_NAMESPACE =\n    options.throwIfNamespace === undefined ? true : !!options.throwIfNamespace;\n\n  const PRAGMA_DEFAULT = options.pragma || 'cinder.createElement';\n  const PRAGMA_FRAG_DEFAULT = options.pragmaFrag || 'cinder.Fragment';\n\n  const JSX_ANNOTATION_REGEX = /\\*?\\s*@jsx\\s+([^\\s]+)/;\n  const JSX_FRAG_ANNOTATION_REGEX = /\\*?\\s*@jsxFrag\\s+([^\\s]+)/;\n\n  // returns a closure that returns an identifier or memberExpression node\n  // based on the given id\n  const createIdentifierParser = (id: string) => () => {\n    const identifiers = id.split('.').map((name) => t.identifier(name));\n    let cur: t.Identifier | t.MemberExpression = identifiers[0];\n    for (let i = 1; i < identifiers.length; i++) {\n      cur = t.memberExpression(cur, identifiers[i]);\n    }\n    return cur;\n  };\n\n  // TODO: Type it properly\n  let setterMap: Map<string, any>;\n  const visitor = helper({\n    pre(state) {\n      const tagName = state.tagName;\n      const args = state.args;\n      if (core.types.react.isCompatTag(tagName)) {\n        args.push(t.stringLiteral(tagName));\n      } else {\n        args.push(state.tagExpr);\n      }\n    },\n\n    post(state, pass) {\n      state.callee = pass.get('jsxIdentifier')();\n    },\n\n    throwIfNamespace: THROW_IF_NAMESPACE,\n  });\n\n  visitor.Program = {\n    enter(path, state) {\n      setterMap = new Map();\n      const { file } = state;\n      //path.unshift(t.memberExpression(t.identifier('swek'), t.identifier(1)));\n      let pragma = PRAGMA_DEFAULT;\n      let pragmaFrag = PRAGMA_FRAG_DEFAULT;\n      let pragmaSet = !!options.pragma;\n      let pragmaFragSet = !!options.pragmaFrag;\n\n      if (file.ast.comments) {\n        for (const comment of file.ast.comments) {\n          const jsxMatches = JSX_ANNOTATION_REGEX.exec(comment.value);\n          if (jsxMatches) {\n            pragma = jsxMatches[1];\n            pragmaSet = true;\n          }\n          const jsxFragMatches = JSX_FRAG_ANNOTATION_REGEX.exec(comment.value);\n          if (jsxFragMatches) {\n            pragmaFrag = jsxFragMatches[1];\n            pragmaFragSet = true;\n          }\n        }\n      }\n\n      state.set('jsxIdentifier', createIdentifierParser(pragma));\n      state.set('jsxFragIdentifier', createIdentifierParser(pragmaFrag));\n      state.set('usedFragment', false);\n      state.set('pragmaSet', pragmaSet);\n      state.set('pragmaFragSet', pragmaFragSet);\n    },\n    exit(path, state) {\n      if (\n        state.get('pragmaSet') &&\n        state.get('usedFragment') &&\n        !state.get('pragmaFragSet')\n      ) {\n        throw new Error(\n          'transform-react-jsx: pragma has been set but ' + 'pragmafrag has not been set',\n        );\n      }\n    },\n  };\n\n  visitor.JSXFragment = function (path: tr.NodePath<t.JSXFragment>) {\n    if (isRootJSXNode(path)) {\n      const outerPath = path.findParent(\n        (parentPath) => parentPath === undefined || parentPath.parentPath.isProgram(),\n      );\n      const domNodes = [\n        ...yieldDomNodeFromJSXFragment(path, false, path.scope, outerPath),\n      ];\n      replacePathWithDomNodeSyntax(domNodes, path, outerPath);\n    }\n  };\n\n  visitor.JSXElement = {\n    exit(path) {\n      if (isRootJSXNode(path)) {\n        const outerPath = path.findParent(\n          (parentPath) => parentPath === undefined || parentPath.parentPath.isProgram(),\n        );\n        const domNode = domNodeFromJSXElement(path, false, path.scope, outerPath);\n        replacePathWithDomNodeSyntax([domNode], path, outerPath);\n      }\n    },\n  };\n\n  return {\n    name: 'transform-react-jsx',\n    inherits: jsx,\n    visitor,\n  };\n});\n"],"file":"index.js"}